# 다익스트라
- 출발점이 정해졌을때 나머지 모든 목적지를 최소비용으로 지나는 알고리즘
- 출발점에서 인접한 목적지의 가중치를 활용해서 비용이 낮은 곳으로 가는 과정을 반복한다
- 반복과정에서 해당 노드에 도달할수있는 최소 가중치값으로 업데이트한다
- 최단거리를 찾는 문제에 사용된다
- heap을 이용해서 시간복잡도 O(nlogn)에 구현이 가능하다
```python
import heapq

def dijkstra_pq(graph, start):
    # graph는 [(현재 인덱스 노드의 인접노드 번호, 인접노드로 가는 가중치)] 의 튜플들이 들어있는 리스트다
    # 예를들어 1번노드에 2,3번 노드가 연결되어있고 각각의 가중치가 5, 6 이며 2번노드에 3번노드가 가중치 7로 연결되어있다면
    # [ [] , [(2,5),(3,6)], [(3,7)] ] 형태다
        
    N = len(graph)    # 총 노드의 갯수
    INF = int(1e9)
    dist = [INF] * N  # 노드별 최단경로값을 저장할 리스트 생성 (초기값 무한)

    q = []
    # 튜플일 경우 0번째 요소 기준으로 최소 힙 생성
    # 첫 번째 방문 누적 비용은 0이다.
    heapq.heappush(q, (0, start))  # 시작노드 start 입력
    dist[start] = 0   # 시작노드에서 시작노드로 가므로 거리 0 설정             
    
    while q:
        # 이때 q 는 (거리,목표노드) 들이 거리에따라 오름차순 되어있다
        # 그러므로 거리가 짧은것부터 차례대로 꺼내며 그 노드에서 또 다른 노드로의 최소거리를 비교한다
        # 이 과정을 반복하면 모든 인접노드간의 최단거리를 갱신하므로 모든 노드간 거리가 최소가 된다
        # 결과적으로 시작점부터 각 노드까지의 거리가 최단거리가 되어있다
        
        # 누적 비용이 가장 작은 녀석을 꺼낸다.
        acc, cur = heapq.heappop(q) # (거리,목표노드) 형태의 우선순위큐에서 pop 하므로 최단거리가 가장 짧은 노드가 나온다

        # 이미 답이 될 가망이 없다
        if dist[cur] < acc:  # 이미 저장되어있는 최소거리값이 지금 입력하려는 거리보다 짧으므로 갱신시키지 않음
            continue         # (이미 처리된적이 있는 노드 라고 생각할 수도 있다) 

        # 인접 노드를 차례대로 살펴보며 거리를 업데이트한다.
        for adj, d in graph[cur]:  # adj = 인접노드번호 , d = 노드까지의 거리
            cost = acc + d         # acc(현재 저장된 최소거리)에 그다음 인접노드까지의 거리를 더한다
            if cost < dist[adj]:   # 만약 그 결과값이 지금 dist에 저장된 거리값보다 작다면(더 최소거리라면)
                dist[adj] = cost   # 거리값을 cost로 갱신한다
                heapq.heappush(q, (cost, adj))  # 갱신된 노드번호와 최소거리값을 힙에다시 집어넣는다
                # 다시 큐에 넣는 이유는 이후 더 멀리있는 노드에 접근할때 이 갱신값을 거쳐서 도달하기 위해서이다
    
    # dist =  [ 0 , start부터 2번까지 최소거리 , start부터 3번까지 최소거리 , ...]
    return dist 
```
