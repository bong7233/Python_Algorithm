# :lock: 전보

주어지는 나라에서 통로를 통해 다른나라로 전보를 보낸다  
통로는 일방통행이며 통로가 없다면 전보를 보내지 못한다  
이때 전보를 받게되는 나라의 수와 전보를 보내는데 걸리는 시간을 구하라

- 시작나라 : C
- 나라의 수 : 1 ~ 30,000
- 통로의 수 : 1 ~ 200,000  

<br>

# :key: 문제 접근
나라의 수가 30000이므로 1초 내에 문제를 풀기위해  

O(nlogn) 시간 복잡도의 다익스트라 사용  
O(n<sup>3</sup>) 의 플로이드 워셜 알고리즘은 사용할 수 없음  

전보를 모두 보내는데 걸리는시간 = 가장 오래걸린 시간  
<br>

```python
import heapq
from sys import stdin

INF = int(1e9)
n,m,start = map(int,stdin.readline().split())
# n : 3   //   m : 2   //   start : 1

graph = [[] for i in range(n+1)]
times = [INF] * (n+1)

for _ in range(m):
    x, y, z = map(int,stdin.readline().split())
    graph[x].append((y,z))

# graph = [[], [(2, 4), (3, 2)], [], []]
print(graph)

def dijk(graph, start):
    q = []
    heapq.heappush(q, (0, start))
    times[start] = 0
    
    while q:
        dist, now = heapq.heappop(q)
        if times[now] < dist: # 이미 최단시간을 기록했다면 pass
            continue
        for i in graph[now]:
            cost = dist + i[1]  # 현재까지의 최단시간과 다음나라까지 걸리는 시간의 합
            if cost < times[i[0]]: # 기존의 최단시간보다 새로운 시간이 더 짧다면
                times[i[0]] = cost # 시간 업데이트
                heapq.heappush(q, (cost, i[0])) # 업데이트된 최단시간을 다시 heap에 push
                
    print(times) # [1000000000, 0, 4, 2]

# 다익스트라 알고리즘 사용
dijk(graph,start)


cnt = 0   # 전보 받는 나라의수 초기화
max_t = 0 # 전보 보내는 총 시간 초기화

# 총 시간이 담겨있는 times
for t in times:
    if t != 1e9:  # 시간이 무한대가 아니라면 ( 연결되어있는 나라라면 )
        cnt += 1  # 전보를 보냈으므로 count + 1
        max_t = max(max_t, t) # 걸린 시간을 비교해서 더 오래걸린 시간으로 변경

# 시작나라를 제외하기위해 -1
print(cnt-1, max_t) # 2 4
```