# :lock: 전보

주어지는 나라에서 통로를 통해 다른나라로 전보를 보낸다  
통로는 일방통행이며 통로가 없다면 전보를 보내지 못한다  
이때 전보를 받게되는 나라의 수와 전보를 보내는데 걸리는 시간을 구하라

- 시작나라 : C
- 나라의 수 : 1 ~ 30,000
- 통로의 수 : 1 ~ 200,000  

<br>

# :key: 문제 접근
나라의 수가 30000이므로 1초 내에 문제를 풀기위해  

O(nlogn) 시간 복잡도의 다익스트라 사용  
O(n<sup>3</sup>) 의 플로이드 워셜 알고리즘은 사용할 수 없음  

전보를 모두 보내는데 걸리는시간 = 가장 오래걸린 시간  
<br>

```python
import heapq
from sys import stdin

INF = int(1e9)
n,m,start = map(int,stdin.readline().split())
# n : 3   //   m : 2   //   start : 1

graph = [[] for i in range(n+1)]
times = [INF] * (n+1)

for _ in range(m):
    x, y, z = map(int,stdin.readline().split())
    graph[x].append((y,z))

# graph = [[], [(2, 4), (3, 2)], [], []]

def dijk(graph, start):
    q = []
    heapq.heappush(q, (0, start)) # 힙을 생성해서 기준이되는 나라의 번호 입력
    times[start] = 0              # 자기 자신에게 가는 시간이므로 초기값 0
    
    while q:
        time, now = heapq.heappop(q)  # 현재 입력되어있는 (전보 보내는 시간, 나라) 불러옴
        if times[now] < time:         # 이미 times에 지금보다 짧은시간이 기록되어있다면 pass
            continue
        for i in graph[now]:
            cost = dist + i[1]        # 현재까지의 전보 최단시간과 다음나라까지 걸리는 시간을 합침
            if cost < times[i[0]]:    # 기존의 최단시간보다 새로운 시간이 더 짧다면
                times[i[0]] = cost    # 시간 업데이트
                heapq.heappush(q, (cost, i[0])) # 업데이트된 최단시간을 다시 heap에 push
                                      # 다시 힙으로 넣는 이유는 해당 나라를통해 또 다른나라로 최단시간을 반복해서 찾기위함
                

# 다익스트라 알고리즘 사용
dijk(graph,start)

# 다익스트라 적용 후 최단시간정보 
# times = [1000000000, 0, 4, 2]


cnt = 0   # 전보 받는 나라의수 초기화
max_t = 0 # 전보 보내는 총 시간 초기화

for t in times:
    if t != 1e9:  # 시간이 무한대가 아니라면 ( 연결되어있는 나라라면 )
        cnt += 1  # 전보를 보냈으므로 count + 1
        max_t = max(max_t, t) # 걸린 시간을 비교해서 더 오래걸린 시간으로 변경

# 시작나라를 제외하기위해 count-1
print(cnt-1, max_t)   # 2 4
```
